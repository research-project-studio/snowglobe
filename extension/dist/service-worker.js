(()=>{"use strict";const e=new Map,t=new Map,s=new Map,o=new Map;let r=!1;function n(e,t){t>0?(chrome.action.setBadgeText({text:t.toString(),tabId:e}),chrome.action.setBadgeBackgroundColor({color:"#4CAF50",tabId:e}),chrome.action.setTitle({title:`WebMap Archiver (${t} map${t>1?"s":""} detected)`,tabId:e})):(chrome.action.setBadgeText({text:"",tabId:e}),chrome.action.setTitle({title:"WebMap Archiver",tabId:e}))}function a(e,t){const s=t<100?`${t}%`:"âœ“";chrome.action.setBadgeText({text:s,tabId:e}),chrome.action.setBadgeBackgroundColor({color:"#2196F3",tabId:e})}chrome.runtime.onMessage.addListener((i,c,d)=>{const l=c.tab?.id||i.tabId;switch(i.type){case"MAPS_DETECTED":l&&function(s,o,r){e.set(s,{count:o,types:r.map(e=>e.type)});const a=t.get(s);a&&"recording"===a.status||n(s,o)}(l,i.count,i.maps);break;case"GET_TAB_STATE":i.tabId&&d({maps:e.get(i.tabId)||{count:0,types:[]},capture:t.get(i.tabId)||{status:"idle"}});break;case"START_CAPTURE":return i.tabId&&async function(e){try{return r?console.log("[WebMap Archiver] Debugger listener already attached"):void 0!==chrome.debugger?(console.log("[WebMap Archiver] Attaching debugger event listener..."),chrome.debugger.onEvent.addListener((e,r,n)=>{const a=e.tabId;if(!a)return;const i=t.get(a);if(i&&"recording"===i.status)switch(r){case"Network.responseReceived":!function(e,r){const{requestId:n,response:a}=r,{url:i,status:c,mimeType:d}=a,l=function(e){const t=[{regex:/\/(\d+)\/(\d+)\/(\d+)\.(pbf|mvt|png|jpg|jpeg|webp|avif)/,groups:[1,2,3]},{regex:/\/tiles\/(\d+)\/(\d+)\/(\d+)/,groups:[1,2,3]},{regex:/[?&]z=(\d+)&x=(\d+)&y=(\d+)/,groups:[1,2,3]},{regex:/[?&]x=(\d+)&y=(\d+)&z=(\d+)/,groups:[3,1,2]},{regex:/\/(\d{1,2})\/(\d+)\/(\d+)(?:\.|\/|$|\?)/,groups:[1,2,3]}];for(const{regex:s,groups:o}of t){const t=e.match(s);if(t){const s=parseInt(t[o[0]]),r=parseInt(t[o[1]]),n=parseInt(t[o[2]]);if(s<0||s>22)continue;try{const t=new URL(e).hostname.split(".");let o=t[0];return"api"===o&&t.length>1&&(o=t[1]),"tiles"===o&&t.length>1&&(o=t[1]),console.log(`[WebMap Archiver] Detected tile: z=${s}, x=${r}, y=${n}, source=${o}, url=${e.substring(0,100)}`),{coords:{z:s,x:r,y:n},source:o||"tiles"}}catch{return{coords:{z:s,x:r,y:n},source:"tiles"}}}}return null}(i);(d.includes("pbf")||d.includes("mvt")||d.includes("protobuf")||d.includes("octet-stream")||i.includes("/tiles/")||/\/\d+\/\d+\/\d+/.test(i))&&console.log(`[WebMap Archiver] Potential tile: ${i.substring(0,120)}`,{mimeType:d,status:c,detected:null!==l});const u={url:i,method:"GET",status:c,mimeType:d,responseSize:0,timestamp:Date.now(),isTile:null!==l,tileCoords:l?.coords,tileSource:l?.source},g=s.get(e)||[];g.push(u),s.set(e,g),o.set(n,{tabId:e,requestId:n});const p=t.get(e);"recording"===p?.status&&(p.totalRequests++,l&&(p.tileCount++,p.zoomLevels.includes(l.coords.z)||(p.zoomLevels.push(l.coords.z),p.zoomLevels.sort((e,t)=>e-t))))}(a,n);break;case"Network.loadingFinished":!async function(e,r){const{requestId:n,encodedDataLength:a}=r;if(!o.get(n))return;o.delete(n);const i=s.get(e);if(!i)return;const c=i.find(e=>e.url&&!e.responseBody);if(c&&(c.responseSize=a,(c.isTile||c.mimeType.includes("json")||c.url.includes("sprite")||c.url.includes("glyphs"))&&a<10485760))try{const s=await chrome.debugger.sendCommand({tabId:e},"Network.getResponseBody",{requestId:n});c.responseBody=s.base64Encoded?s.body:btoa(s.body);const o=t.get(e);"recording"===o?.status&&(o.estimatedSize+=a)}catch(e){console.debug(`[WebMap Archiver] Could not get body for ${c.url}`)}}(a,n)}}),r=!0,console.log("[WebMap Archiver] Debugger event listener attached successfully")):console.error("[WebMap Archiver] chrome.debugger is undefined!"),t.set(e,{status:"recording",startedAt:(new Date).toISOString(),tileCount:0,totalRequests:0,zoomLevels:[],estimatedSize:0}),s.set(e,[]),await chrome.debugger.attach({tabId:e},"1.3"),console.log(`[WebMap Archiver] Debugger attached to tab ${e}`),await chrome.debugger.sendCommand({tabId:e},"Network.enable",{maxResourceBufferSize:104857600,maxTotalBufferSize:209715200}),console.log(`[WebMap Archiver] Network capture enabled for tab ${e}`),chrome.action.setBadgeText({text:"REC",tabId:e}),chrome.action.setBadgeBackgroundColor({color:"#f44336",tabId:e}),console.log(`[WebMap Archiver] Started recording for tab ${e}`),{success:!0}}catch(s){const o=String(s);console.error("[WebMap Archiver] Failed to start capture:",s);let r=o;return o.includes("Cannot access")||o.includes("permission")?r="Cannot attach debugger. Try refreshing the page and trying again.":o.includes("Another debugger")&&(r="Another debugger is already attached. Close DevTools and try again."),t.set(e,{status:"error",message:r}),{success:!1,error:r}}}(i.tabId).then(d),!0;case"STOP_CAPTURE":return i.tabId&&async function(e){const o=t.get(e);if(!o||"recording"!==o.status)return{success:!1,error:"Not recording"};try{await chrome.debugger.detach({tabId:e}),t.set(e,{status:"processing",progress:10,message:"Building capture bundle..."}),a(e,10);const r=s.get(e)||[];t.set(e,{status:"processing",progress:30,message:"Capturing map style..."}),a(e,30);const n=await chrome.tabs.sendMessage(e,{type:"CAPTURE_STYLE"}),i=await chrome.tabs.sendMessage(e,{type:"GET_PAGE_INFO"});t.set(e,{status:"processing",progress:50,message:"Processing tiles..."}),a(e,50);const c=function(e,t,s,o){console.log(`[WebMap Archiver] Building bundle from ${e.length} total requests`);const r=e.filter(e=>e.isTile),n=r.filter(e=>e.responseBody);console.log(`[WebMap Archiver] Tile requests: ${r.length}, with body: ${n.length}`);const a=e.slice(0,10).map(e=>({url:e.url.substring(0,100),isTile:e.isTile,hasBody:!!e.responseBody,mimeType:e.mimeType}));console.log("[WebMap Archiver] Sample requests:",a);const i=e.filter(e=>e.isTile&&e.responseBody).map(e=>({z:e.tileCoords.z,x:e.tileCoords.x,y:e.tileCoords.y,source:e.tileSource,data:e.responseBody,format:e.mimeType.includes("png")?"png":"pbf"}));console.log(`[WebMap Archiver] Final tiles in bundle: ${i.length}`);const c={log:{version:"1.2",creator:{name:"WebMap Archiver",version:"0.1.0"},entries:e.map(e=>({startedDateTime:new Date(e.timestamp).toISOString(),request:{method:e.method,url:e.url,headers:[]},response:{status:e.status,statusText:"OK",headers:[],content:{size:e.responseSize,mimeType:e.mimeType,text:e.responseBody,encoding:e.responseBody?"base64":void 0}},timings:{wait:0,receive:0}}))}};return{version:"1.0",metadata:{url:s.url,title:s.title,capturedAt:(new Date).toISOString(),userAgent:navigator.userAgent,mapLibrary:t?.mapLibrary,captureStats:{totalRequests:e.length,tileCount:i.length,zoomLevels:o.zoomLevels,estimatedSize:o.estimatedSize,recordingDuration:Date.now()-new Date(o.startedAt).getTime()}},viewport:t?.viewport?{center:[t.viewport.center.lng,t.viewport.center.lat],zoom:t.viewport.zoom,bounds:t.viewport.bounds?[[t.viewport.bounds._sw.lng,t.viewport.bounds._sw.lat],[t.viewport.bounds._ne.lng,t.viewport.bounds._ne.lat]]:void 0,bearing:t.viewport.bearing||0,pitch:t.viewport.pitch||0}:{center:[0,0],zoom:10},style:t?.style,har:c,tiles:i}}(r,n,i,o);return s.delete(e),console.log(`[WebMap Archiver] Capture complete: ${c.tiles?.length||0} tiles`),{success:!0,bundle:c}}catch(s){return console.error("[WebMap Archiver] Failed to stop capture:",s),t.set(e,{status:"error",message:String(s)}),{success:!1,error:String(s)}}}(i.tabId).then(d),!0;case"CANCEL_CAPTURE":i.tabId&&(async function(o){try{await chrome.debugger.detach({tabId:o})}catch{}t.set(o,{status:"idle"}),s.delete(o);const r=e.get(o);n(o,r?.count||0)}(i.tabId),d({success:!0}));break;case"PROCESS_BUNDLE":return async function(e){const t=function(){const e=["https://mariogiampieri--webmap-archiver-fastapi-app.modal.run/process"];return e.push("http://localhost:8765"),e.push("http://localhost:8000"),e}();for(const s of t)try{console.log(`[WebMap Archiver] Trying endpoint: ${s}`);const t=await fetch(s,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e),signal:AbortSignal.timeout(3e5)});if(!t.ok){console.warn(`[WebMap Archiver] ${s} returned ${t.status}`);continue}const o=await t.json();if(o.success)return console.log(`[WebMap Archiver] Processing successful via ${s}`),{success:!0,downloadUrl:o.downloadUrl,filename:o.filename,size:o.size};console.warn(`[WebMap Archiver] ${s} processing failed:`,o.error);continue}catch(e){console.warn(`[WebMap Archiver] ${s} request failed:`,e);continue}return console.log("[WebMap Archiver] All processing endpoints failed, falling back to bundle download"),{success:!1,fallbackToDownload:!0,error:"Processing services unavailable"}}(i.bundle).then(d),!0;case"DOWNLOAD_BUNDLE":!function(e,t){const s=JSON.stringify(e,null,2),o=new Blob([s],{type:"application/json"}),r=URL.createObjectURL(o);chrome.downloads.download({url:r,filename:t,saveAs:!0}),setTimeout(()=>URL.revokeObjectURL(r),1e4)}(i.bundle,i.filename)}}),chrome.tabs.onRemoved.addListener(o=>{e.delete(o),t.delete(o),s.delete(o)})})();