(()=>{"use strict";class e{constructor(){this.detectedMaps=[],this.observer=null}detect(){return this.detectedMaps=[],this.detectByDOM(),this.detectMapLibreGL(),this.detectMapboxGL(),this.detectLeaflet(),this.detectOpenLayers(),this.detectedMaps}observe(e){this.observer&&this.observer.disconnect(),this.observer=new MutationObserver(()=>{const n=this.detect();n.length>0&&e(n)}),this.observer.observe(document.body,{childList:!0,subtree:!0})}disconnect(){this.observer&&(this.observer.disconnect(),this.observer=null)}detectByDOM(){document.querySelectorAll(".maplibregl-map").forEach(e=>{if(!this.isAlreadyDetected(e)){const n=this.getMapInstance(e,"maplibre");this.detectedMaps.push({type:"maplibre",version:window.maplibregl?.version,element:e,instance:n})}}),document.querySelectorAll(".mapboxgl-map").forEach(e=>{if(!this.isAlreadyDetected(e)){const n=this.getMapInstance(e,"mapbox");this.detectedMaps.push({type:"mapbox",version:window.mapboxgl?.version,element:e,instance:n})}}),document.querySelectorAll(".leaflet-container").forEach(e=>{if(!this.isAlreadyDetected(e)){const n=this.getMapInstance(e,"leaflet");this.detectedMaps.push({type:"leaflet",version:window.L?.version,element:e,instance:n})}}),document.querySelectorAll(".ol-viewport").forEach(e=>{const n=e.parentElement;n&&!this.isAlreadyDetected(n)&&this.detectedMaps.push({type:"openlayers",version:void 0,element:n,instance:null})}),document.querySelectorAll("canvas").forEach(e=>{const n=e.parentElement;n&&(this.isAlreadyDetected(n)||this.isAlreadyDetected(e)||n.className.toLowerCase().includes("map")&&this.detectedMaps.push({type:"unknown",element:n,instance:null}))})}detectMapLibreGL(){window.maplibregl&&document.querySelectorAll(".maplibregl-map").forEach(e=>{if(this.isAlreadyDetected(e)){const n=this.detectedMaps.find(n=>n.element===e);return n&&!n.version&&(n.version=window.maplibregl?.version),void(n&&!n.instance&&(n.instance=this.getMapInstance(e,"maplibre")||this.findMapInstanceOnWindow(e,"maplibre")))}let n=this.getMapInstance(e,"maplibre");n||(n=this.findMapInstanceOnWindow(e,"maplibre")),this.detectedMaps.push({type:"maplibre",version:window.maplibregl?.version,element:e,instance:n})})}detectMapboxGL(){window.mapboxgl&&document.querySelectorAll(".mapboxgl-map").forEach(e=>{if(this.isAlreadyDetected(e)){const n=this.detectedMaps.find(n=>n.element===e);return n&&!n.version&&(n.version=window.mapboxgl?.version),void(n&&!n.instance&&(n.instance=this.getMapInstance(e,"mapbox")))}const n=this.getMapInstance(e,"mapbox");this.detectedMaps.push({type:"mapbox",version:window.mapboxgl?.version,element:e,instance:n})})}detectLeaflet(){window.L&&document.querySelectorAll(".leaflet-container").forEach(e=>{if(this.isAlreadyDetected(e)){const n=this.detectedMaps.find(n=>n.element===e);return n&&!n.version&&(n.version=window.L?.version),void(n&&!n.instance&&(n.instance=this.getMapInstance(e,"leaflet")))}const n=this.getMapInstance(e,"leaflet");this.detectedMaps.push({type:"leaflet",version:window.L?.version,element:e,instance:n})})}detectOpenLayers(){window.ol&&document.querySelectorAll(".ol-viewport").forEach(e=>{const n=e.parentElement;n&&!this.isAlreadyDetected(n)&&this.detectedMaps.push({type:"openlayers",version:void 0,element:n,instance:null})})}getMapInstance(e,n){const t=["_map","__map","map","_leaflet_map","__maplibregl","__mapboxgl"];for(const o of t){const t=e[o];if(t&&"object"==typeof t&&this.isValidMapInstance(t,n))return t}return Object.keys(e).find(e=>e.startsWith("__reactFiber")||e.startsWith("__reactInternalInstance")),null}isValidMapInstance(e,n){if(!e||"object"!=typeof e)return!1;const t=e;switch(n){case"maplibre":case"mapbox":return"function"==typeof t.getStyle&&"function"==typeof t.getCenter&&"function"==typeof t.getZoom;case"leaflet":return"function"==typeof t.getCenter&&"function"==typeof t.getZoom&&"function"==typeof t.getBounds;default:return!1}}findMapInstanceOnWindow(e,n){const t=window;for(const o of Object.keys(t))try{const a=t[o];if(a&&"object"==typeof a){const t=a;if(this.isValidMapInstance(a,n)&&"function"==typeof t.getContainer){const n=t.getContainer();if(n===e||n?.contains?.(e))return a}}}catch{continue}return null}isAlreadyDetected(e){return this.detectedMaps.some(n=>n.element===e)}}let n=[],t=null;function o(){t=new e,n=t.detect(),a(),t.observe(e=>{n=e,a()}),setTimeout(()=>{n=t.detect(),a()},2e3)}function a(){chrome.runtime.sendMessage({type:"MAPS_DETECTED",count:n.length,maps:n.map(e=>({type:e.type,version:e.version}))})}!function(){const e=document.createElement("script");e.textContent="\n(function() {\n  const log = (msg) => console.log('[WebMap Archiver Hook] ' + msg);\n\n  log('Installing map constructor hooks...');\n\n  // Hook Mapbox GL JS constructor\n  if (window.mapboxgl && window.mapboxgl.Map) {\n    const OriginalMap = window.mapboxgl.Map;\n    window.mapboxgl.Map = function(...args) {\n      const instance = new OriginalMap(...args);\n      log('Captured Mapbox GL JS map instance');\n      window.__webmapArchiverMapInstance = instance;\n      return instance;\n    };\n    // Preserve prototype and static properties\n    window.mapboxgl.Map.prototype = OriginalMap.prototype;\n    Object.setPrototypeOf(window.mapboxgl.Map, OriginalMap);\n    log('Mapbox GL JS constructor hooked');\n  }\n\n  // Hook MapLibre GL JS constructor\n  if (window.maplibregl && window.maplibregl.Map) {\n    const OriginalMap = window.maplibregl.Map;\n    window.maplibregl.Map = function(...args) {\n      const instance = new OriginalMap(...args);\n      log('Captured MapLibre GL JS map instance');\n      window.__webmapArchiverMapInstance = instance;\n      return instance;\n    };\n    window.maplibregl.Map.prototype = OriginalMap.prototype;\n    Object.setPrototypeOf(window.maplibregl.Map, OriginalMap);\n    log('MapLibre GL JS constructor hooked');\n  }\n\n  // If libraries haven't loaded yet, watch for them\n  if (!window.mapboxgl && !window.maplibregl) {\n    log('Libraries not loaded yet, watching for them...');\n\n    const checkInterval = setInterval(() => {\n      if (window.mapboxgl && window.mapboxgl.Map && !window.mapboxgl.Map.__hooked) {\n        const OriginalMap = window.mapboxgl.Map;\n        window.mapboxgl.Map = function(...args) {\n          const instance = new OriginalMap(...args);\n          log('Captured Mapbox GL JS map instance (delayed)');\n          window.__webmapArchiverMapInstance = instance;\n          return instance;\n        };\n        window.mapboxgl.Map.prototype = OriginalMap.prototype;\n        Object.setPrototypeOf(window.mapboxgl.Map, OriginalMap);\n        window.mapboxgl.Map.__hooked = true;\n        log('Mapbox GL JS constructor hooked (delayed)');\n        clearInterval(checkInterval);\n      }\n\n      if (window.maplibregl && window.maplibregl.Map && !window.maplibregl.Map.__hooked) {\n        const OriginalMap = window.maplibregl.Map;\n        window.maplibregl.Map = function(...args) {\n          const instance = new OriginalMap(...args);\n          log('Captured MapLibre GL JS map instance (delayed)');\n          window.__webmapArchiverMapInstance = instance;\n          return instance;\n        };\n        window.maplibregl.Map.prototype = OriginalMap.prototype;\n        Object.setPrototypeOf(window.maplibregl.Map, OriginalMap);\n        window.maplibregl.Map.__hooked = true;\n        log('MapLibre GL JS constructor hooked (delayed)');\n        clearInterval(checkInterval);\n      }\n    }, 50);\n\n    // Stop checking after 5 seconds\n    setTimeout(() => clearInterval(checkInterval), 5000);\n  }\n})();\n",(document.head||document.documentElement).appendChild(e),e.remove()}(),chrome.runtime.onMessage.addListener((e,t,o)=>{switch(e.type){case"GET_MAPS":o({count:n.length,maps:n.map(e=>({type:e.type,version:e.version}))});break;case"CAPTURE_STYLE":return new Promise(e=>{const n=document.createElement("script");n.textContent="\n      (function() {\n        // Helper function to capture from a map instance\n        function captureFromInstance(instance) {\n          if (instance && typeof instance.getStyle === 'function') {\n            try {\n              const style = instance.getStyle();\n              const viewport = {\n                center: instance.getCenter?.() || [0, 0],\n                zoom: instance.getZoom?.() || 0,\n                bounds: instance.getBounds?.(),\n                bearing: instance.getBearing?.() || 0,\n                pitch: instance.getPitch?.() || 0,\n              };\n              window.postMessage({\n                type: 'WEBMAP_ARCHIVER_CAPTURE',\n                style: style,\n                viewport: viewport,\n              }, '*');\n              return true;\n            } catch (e) {\n              console.error('WebMap Archiver: Failed to capture style', e);\n            }\n          }\n          return false;\n        }\n\n        // Strategy 1: Check common window properties\n        const windowCandidates = [\n          window.map,\n          window.maplibreMap,\n          window.mapboxMap,\n        ];\n\n        for (const candidate of windowCandidates) {\n          if (captureFromInstance(candidate)) return;\n        }\n\n        // Strategy 2: Check map containers with special properties\n        const containers = document.querySelectorAll('.maplibregl-map, .mapboxgl-map');\n        for (const container of containers) {\n          // Try MapLibre/Mapbox internal properties\n          if (captureFromInstance(container.__maplibregl_map)) return;\n          if (captureFromInstance(container.__mapboxgl_map)) return;\n\n          // Try common custom property names\n          for (const prop of ['_map', '__map', 'map']) {\n            if (captureFromInstance(container[prop])) return;\n          }\n\n          // Try React fiber internals (for React apps)\n          try {\n            const fiberKey = Object.keys(container).find(k => k.startsWith('__reactFiber'));\n            if (fiberKey) {\n              const fiber = container[fiberKey];\n              // Walk up the fiber tree looking for map instance\n              let current = fiber;\n              let depth = 0;\n              while (current && depth < 20) {\n                // Check memoizedState (hooks)\n                if (current.memoizedState) {\n                  let state = current.memoizedState;\n                  while (state) {\n                    if (captureFromInstance(state.memoizedState)) return;\n                    state = state.next;\n                  }\n                }\n                // Check memoizedProps\n                if (current.memoizedProps) {\n                  for (const key in current.memoizedProps) {\n                    if (captureFromInstance(current.memoizedProps[key])) return;\n                  }\n                }\n                // Check stateNode (class component instance)\n                if (current.stateNode && typeof current.stateNode === 'object') {\n                  for (const key in current.stateNode) {\n                    if (captureFromInstance(current.stateNode[key])) return;\n                  }\n                }\n                current = current.return;\n                depth++;\n              }\n            }\n          } catch (e) {\n            console.error('React fiber traversal error:', e);\n          }\n        }\n\n        // Strategy 3: Fallback - scan all window properties\n        for (const key of Object.keys(window)) {\n          const obj = window[key];\n          if (captureFromInstance(obj)) return;\n        }\n\n        // No map found\n        window.postMessage({ type: 'WEBMAP_ARCHIVER_CAPTURE', style: null }, '*');\n      })();\n    ";const t=n=>{"WEBMAP_ARCHIVER_CAPTURE"===n.data?.type&&(window.removeEventListener("message",t),e(n.data.style))};window.addEventListener("message",t),document.documentElement.appendChild(n),n.remove(),setTimeout(()=>{window.removeEventListener("message",t),e(null)},5e3)}).then(e=>{o(e)}),!0;case"GET_PAGE_INFO":o({url:window.location.href,title:document.title})}}),"loading"===document.readyState?document.addEventListener("DOMContentLoaded",o):o()})();