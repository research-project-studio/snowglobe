(()=>{"use strict";!function(){let e=!1,t=0,n=[],o=0,r=0,s=new Set,a=null,l=null,i=null,c=null;const d=document.getElementById("idle-state"),u=document.getElementById("recording-state"),p=document.getElementById("processing-state"),m=document.getElementById("complete-state"),g=document.getElementById("error-state"),y=document.getElementById("map-status"),h=document.getElementById("start-btn"),b=document.getElementById("test-debugger-btn"),f=document.getElementById("recording-duration"),v=document.getElementById("stat-tiles"),w=document.getElementById("stat-requests"),C=document.getElementById("stat-size"),I=document.getElementById("stat-zooms"),S=document.getElementById("tile-list"),E=document.getElementById("stop-btn"),x=document.getElementById("cancel-btn"),M=(document.getElementById("processing-title"),document.getElementById("processing-message")),T=document.getElementById("progress-fill"),L=document.getElementById("progress-label"),k=document.getElementById("complete-filename"),A=document.getElementById("complete-stats"),B=document.getElementById("download-btn"),W=document.getElementById("download-bundle-btn"),D=document.getElementById("new-capture-btn"),O=document.getElementById("error-message"),P=document.getElementById("retry-btn");async function $(){try{const t=await(e={type:"GET_MAPS"},new Promise(t=>{chrome.devtools.inspectedWindow.eval(`(() => {\n        return new Promise((resolve) => {\n          chrome.runtime.sendMessage(${JSON.stringify(e)}, resolve);\n        });\n      })()`,(e,n)=>{n?(console.error("Content script error:",n),t(null)):t(e)})}));if(t&&t.count>0){const e=t.maps.map(e=>e.type).join(", ");y.textContent=`${t.count} map${t.count>1?"s":""} detected (${e})`}else y.textContent="No maps detected on this page"}catch(e){y.textContent="Unable to detect maps"}var e}function j(e){switch(d.classList.add("hidden"),u.classList.add("hidden"),p.classList.add("hidden"),m.classList.add("hidden"),g.classList.add("hidden"),e){case"idle":d.classList.remove("hidden");break;case"recording":u.classList.remove("hidden");break;case"processing":p.classList.remove("hidden");break;case"complete":m.classList.remove("hidden");break;case"error":g.classList.remove("hidden")}}function R(){const e={reloadOnStart:!0,expandCoverage:!0,archiveMode:"standalone"};try{const t=document.getElementById("opt-reload-page"),n=document.getElementById("opt-expand-coverage"),o=document.getElementById("opt-archive-mode");return{reloadOnStart:t?.checked??e.reloadOnStart,expandCoverage:n?.checked??e.expandCoverage,archiveMode:o?.value??e.archiveMode}}catch(t){return console.warn("[WebMap Archiver] Error reading options, using defaults:",t),e}}function z(){const e=document.getElementById("options-panel"),t=document.getElementById("options-content");e&&t&&(e.classList.toggle("expanded"),t.classList.toggle("collapsed"))}async function F(){console.log("[WebMap Archiver] Starting recording...");const l=R();if(n=[],o=0,r=0,s.clear(),e=!0,t=Date.now(),v.textContent="0",w.textContent="0",C.textContent="0 B",I.textContent="-",chrome.devtools.network.onRequestFinished.addListener(N),a=setInterval(_,1e3),chrome.runtime.sendMessage({type:"CAPTURE_STARTED",tabId:chrome.devtools.inspectedWindow.tabId}),l.reloadOnStart){S.innerHTML='<p class="empty-message">Reloading page to capture all resources...</p>';try{console.log("[WebMap Archiver] Reloading page to capture initial resources..."),await chrome.devtools.inspectedWindow.reload({ignoreCache:!0}),await new Promise(e=>setTimeout(e,300))}catch(e){console.error("[WebMap Archiver] Failed to reload page:",e)}}S.innerHTML='<p class="empty-message">Pan or zoom the map to capture tiles...</p>',j("recording"),console.log("[WebMap Archiver] Recording started")}function N(t){if(!e)return;const o=t.request.url,r=t.response.content.mimeType||"",s=t.response.status,a=t.response.content.size||0;console.log(`[WebMap Archiver] Request: ${o.substring(0,80)}... (${r})`);const l=function(e){const t=[{regex:/\/(\d+)\/(\d+)\/(\d+)\.(pbf|mvt|png|jpg|jpeg|webp|avif)/,groups:[1,2,3]},{regex:/\/tiles\/(\d+)\/(\d+)\/(\d+)/,groups:[1,2,3]},{regex:/[?&]z=(\d+)&x=(\d+)&y=(\d+)/,groups:[1,2,3]},{regex:/\/(\d{1,2})\/(\d+)\/(\d+)(?:\.|\/|$|\?)/,groups:[1,2,3]}];for(const{regex:n,groups:o}of t){const t=e.match(n);if(t){const n=parseInt(t[o[0]]),r=parseInt(t[o[1]]),s=parseInt(t[o[2]]);if(n<0||n>22)continue;try{const t=new URL(e).hostname.split(".");let o=t[0];return("api"===o||"tiles"===o)&&t.length>1&&(o=t[1]),{coords:{z:n,x:r,y:s},source:o||"tiles"}}catch{return{coords:{z:n,x:r,y:s},source:"tiles"}}}}return null}(o),i=function(e){return Q.some(t=>t.test(e))}(o),c=function(e){return X.some(t=>t.test(e))}(o),d={url:o,method:t.request.method,status:s,mimeType:r,size:a,isTile:null!==l,tileCoords:l?.coords,tileSource:l?.source,isSprite:i,spriteInfo:i?Y(o):void 0,isGlyph:c,glyphInfo:c?ee(o):void 0};(null!==l||i||c||r.includes("json")||r.includes("pbf")||r.includes("protobuf")||o.includes("style"))&&a<10485760?t.getContent((e,t)=>{e&&(d.body="base64"===t?e:btoa(e)),n.push(d),U(d)}):(n.push(d),U(d))}function U(e){if(w.textContent=n.length.toString(),r+=e.size,C.textContent=te(r),e.isTile&&e.tileCoords){o++,v.textContent=o.toString(),s.add(e.tileCoords.z);const t=Array.from(s).sort((e,t)=>e-t);I.textContent=t.length>0?`${t[0]}-${t[t.length-1]}`:"-",function(e){const t=S.querySelector(".empty-message");t&&t.remove();const n=document.createElement("div");for(n.className="tile-item new",n.textContent=`z${e.tileCoords.z}/${e.tileCoords.x}/${e.tileCoords.y} (${e.tileSource})`,S.insertBefore(n,S.firstChild);S.children.length>20;)S.removeChild(S.lastChild)}(e),console.log(`[WebMap Archiver] âœ… Tile captured: z${e.tileCoords.z}/${e.tileCoords.x}/${e.tileCoords.y}`)}chrome.runtime.sendMessage({type:"CAPTURE_STATS_UPDATE",tabId:chrome.devtools.inspectedWindow.tabId,stats:{tileCount:o,totalRequests:n.length,estimatedSize:r,zoomLevels:Array.from(s)}})}function _(){const e=Math.floor((Date.now()-t)/1e3),n=Math.floor(e/60),o=e%60;f.textContent=`${n}:${o.toString().padStart(2,"0")}`}async function q(){console.log("[WebMap Archiver] Stopping recording..."),e=!1,chrome.devtools.network.onRequestFinished.removeListener(N),a&&(clearInterval(a),a=null),j("processing"),J(10,"Extracting map state...");try{const e=await new Promise(e=>{chrome.devtools.inspectedWindow.eval("({ url: window.location.href, title: document.title })",(t,n)=>{if(n)console.error("[WebMap Archiver] Failed to get page info:",n),e({url:"https://unknown",title:"Unknown Page"});else if(t&&"object"==typeof t){const n=t;e({url:n.url||"https://unknown",title:n.title||"Unknown Page"})}else e({url:"https://unknown",title:"Unknown Page"})})});console.log("[WebMap Archiver] Page info:",e),J(20,"Extracting map style and GeoJSON...");const t=await async function(){console.log("[WebMap Archiver] Capturing map state via debugger API...");const e=chrome.devtools.inspectedWindow.tabId;return new Promise(t=>{chrome.debugger.attach({tabId:e},"1.3",()=>{if(chrome.runtime.lastError)return console.error("[WebMap Archiver] Failed to attach debugger:",chrome.runtime.lastError),void t({style:null,viewport:null,mapLibrary:null,error:"Failed to attach debugger"});console.log("[WebMap Archiver] Debugger attached, evaluating capture script..."),chrome.debugger.sendCommand({tabId:e},"Runtime.evaluate",{expression:"\n              (() => {\n                const log = (msg) => console.log('[WebMap Archiver] ' + msg);\n                const error = (msg) => console.error('[WebMap Archiver] ' + msg);\n\n                try {\n                  log('Starting capture...');\n\n                  // Find the map instance\n                  let map = null;\n\n                  // Strategy 1: Try 'map' variable directly\n                  try {\n                    if (typeof map !== 'undefined' && map && typeof map.getStyle === 'function') {\n                      log('Found map via direct access');\n                    }\n                  } catch (e) {\n                    log('Direct map access failed, trying eval...');\n                  }\n\n                  // Strategy 2: Use eval to access script-scoped variables\n                  if (!map) {\n                    const varNames = ['map', 'mapInstance', 'mapboxMap', 'maplibreMap', 'glMap', 'mainMap', 'myMap'];\n                    for (const varName of varNames) {\n                      try {\n                        const candidate = eval(varName);\n                        if (candidate && typeof candidate.getStyle === 'function') {\n                          log('Found map via eval(' + varName + ')');\n                          map = candidate;\n                          break;\n                        }\n                      } catch (e) {\n                        // Variable doesn't exist\n                      }\n                    }\n                  }\n\n                  // Strategy 3: Check window.map\n                  if (!map && window.map && typeof window.map.getStyle === 'function') {\n                    log('Found map via window.map');\n                    map = window.map;\n                  }\n\n                  if (!map) {\n                    error('Could not find map instance');\n                    return { error: 'Map instance not found' };\n                  }\n\n                  // Detect library\n                  let mapLibrary = { type: 'unknown', version: null };\n                  if (window.mapboxgl) {\n                    mapLibrary = { type: 'mapbox', version: window.mapboxgl.version };\n                  } else if (window.maplibregl) {\n                    mapLibrary = { type: 'maplibre', version: window.maplibregl.version };\n                  }\n                  log('Library: ' + mapLibrary.type + ' v' + mapLibrary.version);\n\n                  // Extract style\n                  let style = null;\n                  try {\n                    style = map.getStyle();\n                    log('Got style with ' + Object.keys(style.sources || {}).length + ' sources');\n                  } catch (e) {\n                    error('Failed to get style: ' + e.message);\n                    return { error: 'Failed to get style: ' + e.message };\n                  }\n\n                  // Extract viewport\n                  let viewport = null;\n                  try {\n                    const center = map.getCenter();\n                    const bounds = map.getBounds();\n                    viewport = {\n                      center: { lng: center.lng, lat: center.lat },\n                      zoom: map.getZoom(),\n                      bearing: map.getBearing ? map.getBearing() : 0,\n                      pitch: map.getPitch ? map.getPitch() : 0,\n                      bounds: bounds ? {\n                        _sw: { lng: bounds.getWest(), lat: bounds.getSouth() },\n                        _ne: { lng: bounds.getEast(), lat: bounds.getNorth() }\n                      } : null\n                    };\n                    log('Got viewport: zoom=' + viewport.zoom.toFixed(1));\n                  } catch (e) {\n                    error('Failed to get viewport: ' + e.message);\n                  }\n\n                  // Extract GeoJSON from sources\n                  if (style && style.sources) {\n                    const geojsonSourceIds = Object.entries(style.sources)\n                      .filter(([, src]) => src.type === 'geojson')\n                      .map(([id]) => id);\n\n                    log('GeoJSON sources: ' + geojsonSourceIds.join(', '));\n\n                    for (const sourceId of geojsonSourceIds) {\n                      try {\n                        const features = map.querySourceFeatures(sourceId);\n                        log(sourceId + ': ' + (features ? features.length : 0) + ' features from querySourceFeatures');\n\n                        if (features && features.length > 0) {\n                          // Deduplicate\n                          const seen = new Map();\n                          const unique = [];\n                          for (const f of features) {\n                            const key = f.id !== undefined ? String(f.id) : JSON.stringify(f.geometry);\n                            if (!seen.has(key)) {\n                              seen.set(key, true);\n                              unique.push({\n                                type: 'Feature',\n                                geometry: f.geometry,\n                                properties: f.properties || {},\n                                ...(f.id !== undefined && { id: f.id })\n                              });\n                            }\n                          }\n\n                          style.sources[sourceId].data = {\n                            type: 'FeatureCollection',\n                            features: unique\n                          };\n                          log(sourceId + ': injected ' + unique.length + ' unique features');\n                        } else {\n                          // Fallback: try to get data from source object\n                          const source = map.getSource(sourceId);\n                          if (source && source._data) {\n                            style.sources[sourceId].data = source._data;\n                            log(sourceId + ': used _data fallback');\n                          }\n                        }\n                      } catch (e) {\n                        error(sourceId + ' extraction failed: ' + e.message);\n                      }\n                    }\n                  }\n\n                  log('Capture complete');\n                  return {\n                    style: style,\n                    viewport: viewport,\n                    mapLibrary: mapLibrary\n                  };\n\n                } catch (e) {\n                  error('Capture failed: ' + e.message);\n                  return { error: e.message };\n                }\n              })();\n            ",includeCommandLineAPI:!0,returnByValue:!0},n=>{if(chrome.debugger.detach({tabId:e},()=>{console.log("[WebMap Archiver] Debugger detached")}),chrome.runtime.lastError)return console.error("[WebMap Archiver] Runtime.evaluate failed:",chrome.runtime.lastError),void t({style:null,viewport:null,mapLibrary:null,error:String(chrome.runtime.lastError)});if(!n||!n.result)return console.error("[WebMap Archiver] No result from capture"),void t({style:null,viewport:null,mapLibrary:null,error:"No result from capture"});const o=n.result.value;if(o.error)return console.error("[WebMap Archiver] Capture error:",o.error),void t({style:null,viewport:null,mapLibrary:null,error:o.error});console.log("[WebMap Archiver] Capture successful:",{hasStyle:!!o.style,hasViewport:!!o.viewport,sources:Object.keys(o.style?.sources||{}).length,layers:o.style?.layers?.length||0}),t(o)})})})}();if(console.log("[WebMap Archiver] Capture result:",{hasStyle:!!t.style,hasViewport:!!t.viewport,mapLibrary:t.mapLibrary,error:t.error}),t.error&&console.warn("[WebMap Archiver] Capture warning:",t.error),t.style?.sources){console.log("[WebMap Archiver] Captured sources:",Object.keys(t.style.sources));const e=Object.entries(t.style.sources).filter(([,e])=>"geojson"===e.type);for(const[t,n]of e){const e=n.data;e&&e.features?console.log(`[WebMap Archiver] GeoJSON '${t}': ${e.features.length} features`):console.log(`[WebMap Archiver] GeoJSON '${t}': no data captured`)}}J(30,"Building capture bundle...");const o=function(e,t){const o=R(),r=n.filter(e=>e.isTile&&e.body&&e.tileCoords).map(e=>({z:e.tileCoords.z,x:e.tileCoords.x,y:e.tileCoords.y,sourceId:e.tileSource||"tiles",url:e.url,data:e.body,format:e.mimeType.includes("png")?"png":e.mimeType.includes("jpg")||e.mimeType.includes("jpeg")?"jpg":e.mimeType.includes("webp")?"webp":"pbf"})),s=n.filter(e=>(e.isSprite||e.isGlyph)&&e.body).map(e=>{if(e.isSprite&&e.spriteInfo)return{resourceType:"sprite",url:e.url,data:e.body,variant:e.spriteInfo.variant,contentType:e.spriteInfo.contentType};if(e.isGlyph&&e.glyphInfo){const[t,n]=e.glyphInfo.range.split("-").map(e=>parseInt(e));return{resourceType:"glyph",url:e.url,data:e.body,fontStack:e.glyphInfo.fontStack,rangeStart:t,rangeEnd:n}}return null}).filter(e=>null!==e);console.log(`[WebMap Archiver] Bundle resources: ${s.length} (${s.filter(e=>"sprite"===e.resourceType).length} sprites, ${s.filter(e=>"glyph"===e.resourceType).length} glyphs)`);const a={log:{version:"1.2",creator:{name:"WebMap Archiver",version:"0.3.2"},entries:n.map(e=>({startedDateTime:(new Date).toISOString(),request:{method:e.method,url:e.url,headers:[]},response:{status:e.status,statusText:200===e.status?"OK":"Error",headers:[],content:{size:e.size,mimeType:e.mimeType,text:e.body,encoding:e.body?"base64":void 0}},timings:{wait:0,receive:0}}))}};let l={center:[0,0],zoom:10};if(e?.viewport){const t=e.viewport;l={center:[t.center?.lng??t.center?.[0]??0,t.center?.lat??t.center?.[1]??0],zoom:t.zoom??10,bearing:t.bearing??0,pitch:t.pitch??0},t.bounds&&(l.bounds=[[t.bounds._sw?.lng??t.bounds[0]?.[0],t.bounds._sw?.lat??t.bounds[0]?.[1]],[t.bounds._ne?.lng??t.bounds[1]?.[0],t.bounds._ne?.lat??t.bounds[1]?.[1]]])}return{version:"1.0",metadata:{url:t.url,title:t.title,capturedAt:(new Date).toISOString(),userAgent:navigator.userAgent,mapLibrary:e?.mapLibrary?{type:e.mapLibrary.type||"unknown",version:e.mapLibrary.version}:void 0},viewport:l,style:e?.style||null,har:a,tiles:r,resources:s,options:{expandCoverage:o.expandCoverage,archiveMode:o.archiveMode}}}({style:t.style||null,viewport:t.viewport||null,mapLibrary:t.mapLibrary||null},e);l=o,console.log("[WebMap Archiver] Bundle built:",{tiles:o.tiles?.length||0,harEntries:o.har?.log?.entries?.length||0,hasStyle:!!o.style,styleSourceCount:o.style?Object.keys(o.style.sources||{}).length:0,styleLayerCount:o.style?.layers?.length||0}),J(50,"Uploading to cloud...");const s=await chrome.runtime.sendMessage({type:"PROCESS_BUNDLE",bundle:o});if(s.success)J(90,"Preparing download..."),i=s.downloadUrl,c=s.filename,chrome.runtime.sendMessage({type:"CAPTURE_STOPPED",tabId:chrome.devtools.inspectedWindow.tabId}),V(s.filename,o.tiles?.length||0,s.size||0);else{if(!s.fallbackToDownload)throw new Error(s.error||"Processing failed");c=function(e){try{return`${new URL(e).hostname.replace(/\./g,"-")}-${(new Date).toISOString().split("T")[0]}.webmap-capture.json`}catch{return`webmap-${Date.now()}.webmap-capture.json`}}(e.url),chrome.runtime.sendMessage({type:"CAPTURE_STOPPED",tabId:chrome.devtools.inspectedWindow.tabId}),V(c,o.tiles?.length||0,r,!0)}}catch(e){console.error("[WebMap Archiver] Error:",e),t=String(e),O.textContent=t,j("error")}var t}function G(){e=!1,chrome.devtools.network.onRequestFinished.removeListener(N),a&&(clearInterval(a),a=null),chrome.runtime.sendMessage({type:"CAPTURE_STOPPED",tabId:chrome.devtools.inspectedWindow.tabId}),H()}function J(e,t){T.style.width=`${e}%`,L.textContent=`${e}%`,M.textContent=t}function V(e,t,n,o=!1){k.textContent=e,A.textContent=`${t} tiles â€¢ ${te(n)}`,o?(B.textContent="ðŸ“¦ Download Capture Bundle",B.onclick=Z,W.classList.add("hidden")):(B.textContent="â¬‡ï¸ Download Archive",B.onclick=K,W.classList.remove("hidden")),j("complete")}function H(){n=[],o=0,r=0,s.clear(),l=null,i=null,c=null,$(),j("idle")}function K(){i&&c&&chrome.runtime.sendMessage({type:"DOWNLOAD_FILE",url:i,filename:c})}function Z(){if(l&&c){const e=c.replace(".zip",".webmap-capture.json");chrome.runtime.sendMessage({type:"DOWNLOAD_BUNDLE",bundle:l,filename:e})}}const Q=[/\/sprite(@\dx)?\.(png|json)(\?|$)/i,/\/sprites?\//i],X=[/\/fonts\/[^/]+\/\d+-\d+\.pbf/i,/\/glyphs?\//i];function Y(e){const t=e.match(/\/(sprite(@\dx)?\.(png|json))(\?|$)/i),n=t?t[1]:"sprite.png",o=t&&t[2]?t[2].substring(1):"1x",r=n.endsWith(".json")?"json":"image";return{filename:n,variant:o,contentType:r}}function ee(e){const t=e.match(/\/fonts\/([^/]+)\/(\d+-\d+)\.pbf/i);return t?{fontStack:decodeURIComponent(t[1]),range:t[2]}:{fontStack:"unknown",range:"0-255"}}function te(e){if(0===e)return"0 B";const t=Math.floor(Math.log(e)/Math.log(1024));return parseFloat((e/Math.pow(1024,t)).toFixed(1))+" "+["B","KB","MB","GB"][t]}function ne(){console.log("[Debugger Test] Starting test..."),b.disabled=!0,b.textContent="ðŸ”¬ Testing...";const e=chrome.devtools.inspectedWindow.tabId;console.log("[Debugger Test] Tab ID:",e),chrome.debugger.attach({tabId:e},"1.3",()=>{if(chrome.runtime.lastError)return console.error("[Debugger Test] Failed to attach:",chrome.runtime.lastError),b.disabled=!1,b.textContent="ðŸ”¬ Test Failed - See Console",void setTimeout(()=>{b.textContent="ðŸ”¬ Test Debugger API"},3e3);console.log("[Debugger Test] âœ… Debugger attached successfully"),chrome.debugger.sendCommand({tabId:e},"Runtime.evaluate",{expression:"\n            (() => {\n              const results = [];\n\n              // Test 1: Check if 'map' exists\n              try {\n                if (typeof map !== 'undefined' && map && typeof map.getStyle === 'function') {\n                  results.push({ test: 'map variable', result: 'SUCCESS - map found and has getStyle()' });\n\n                  // Try to get style\n                  try {\n                    const style = map.getStyle();\n                    results.push({\n                      test: 'map.getStyle()',\n                      result: 'SUCCESS',\n                      sources: Object.keys(style.sources || {}).length,\n                      layers: (style.layers || []).length\n                    });\n                  } catch (e) {\n                    results.push({ test: 'map.getStyle()', result: 'ERROR: ' + e.message });\n                  }\n                } else {\n                  results.push({ test: 'map variable', result: 'FAILED - map not found or missing getStyle()' });\n                }\n              } catch (e) {\n                results.push({ test: 'map variable', result: 'ERROR: ' + e.message });\n              }\n\n              // Test 2: Check window.map\n              results.push({ test: 'window.map', result: typeof window.map });\n\n              // Test 3: Check for map on container\n              const container = document.querySelector('.mapboxgl-map, .maplibregl-map');\n              if (container) {\n                const keys = Object.keys(container);\n                results.push({ test: 'container keys', result: keys.join(', ') || 'none' });\n              }\n\n              return results;\n            })()\n          ",includeCommandLineAPI:!0,returnByValue:!0},t=>{if(console.log("[Debugger Test] Results:",t),t?.result?.value){const e=t.result.value;console.log("[Debugger Test] Test Results:"),e.forEach(e=>{console.log("  "+e.test+":",e.result,e.sources?"sources:"+e.sources:"",e.layers?"layers:"+e.layers:"")});const n=e.find(e=>"map variable"===e.test);n&&n.result.includes("SUCCESS")?(b.textContent="âœ… Success! Map Accessible",b.style.backgroundColor="#10b981"):(b.textContent="âŒ Map Not Accessible",b.style.backgroundColor="#ef4444")}else console.error("[Debugger Test] No result value"),b.textContent="âŒ Test Failed";chrome.debugger.detach({tabId:e},()=>{console.log("[Debugger Test] Debugger detached"),b.disabled=!1,setTimeout(()=>{b.textContent="ðŸ”¬ Test Debugger API",b.style.backgroundColor=""},5e3)})})})}document.addEventListener("DOMContentLoaded",function(){!function(){h.addEventListener("click",F),E.addEventListener("click",q),x.addEventListener("click",G),b.addEventListener("click",ne),W.addEventListener("click",Z),D.addEventListener("click",H),P.addEventListener("click",H);const e=document.getElementById("options-header");e&&e.addEventListener("click",z)}(),$(),j("idle")})}()})();