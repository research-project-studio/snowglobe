<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NYC Parking Regulations - WebMap Archive</title>
    <link
      href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css"
      rel="stylesheet"
    />
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    <script src="https://unpkg.com/pmtiles@3.0.7/dist/pmtiles.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, sans-serif;
      }
      #map {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 100%;
      }
      .info-panel {
        position: absolute;
        top: 10px;
        left: 10px;
        background: white;
        padding: 12px 16px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        max-width: 300px;
        font-size: 13px;
        z-index: 100;
      }
      .info-panel h1 {
        font-size: 16px;
        margin-bottom: 8px;
      }
      .info-panel .meta {
        color: #666;
        line-height: 1.6;
      }
      .layer-toggle {
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid #eee;
      }
      .layer-toggle label {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        padding: 4px 0;
      }
      .layer-toggle input {
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <div class="info-panel">
      <h1>NYC Parking Regulations</h1>
      <div class="meta">
        <div>Archived: 2025-12-06</div>
        <div>Zoom: 10-13</div>
        <div>Sources: 2</div>
      </div>
      <div class="layer-toggle" id="layer-controls"></div>
    </div>
    <script>
      // Register PMTiles protocol with MapLibre
      let protocol = new pmtiles.Protocol();
      maplibregl.addProtocol("pmtiles", protocol.tile);

      // Archive configuration
      const config = {
        name: "NYC Parking Regulations",
        bounds: {
          west: -74.53125,
          south: 40.44694705960049,
          east: -73.4765625,
          north: 40.97989806962013,
        },
        minZoom: 10,
        maxZoom: 13,
        tileSources: [
          {
            name: "maptiler-385.pbf",
            path: "tiles/maptiler-385.pbf.pmtiles",
            type: "vector",
            isOrphan: false,
            extractedStyle: {
              sourceLayer: "aerodrome_label",
              allLayers: [
                "aerodrome_label",
                "aeroway",
                "boundary",
                "landcover",
                "landuse",
                "mountain_peak",
                "park",
                "place",
                "transportation",
                "transportation_name",
                "water",
                "water_name",
                "waterway",
                "poi",
                "building",
              ],
              colors: {},
              layerType: "line",
              confidence: 0.0,
            },
          },
          {
            name: "wxy-labs-parking_regs_v2",
            path: "tiles/wxy-labs-parking_regs_v2.pmtiles",
            type: "vector",
            isOrphan: true,
            extractedStyle: {
              sourceLayer: "parking_reg_sections_3fgb",
              allLayers: ["parking_reg_sections_3fgb"],
              colors: {
                vehicle: "#a432a8",
                open: "#32a852",
                bus: "#329aa8",
                limited: "#a89832",
                stop_stand: "#a86b32",
                none: "#a83232",
                gov: "#7532a8",
                no_regs: "#517369",
                unknown: "#FFFFFF",
              },
              layerType: "symbol",
              confidence: 0.9,
            },
          },
        ],
        createdAt: "2025-12-06",
      };

      // Color palette for data layers WITHOUT extracted styling
      const DEFAULT_COLORS = [
        "#e41a1c",
        "#377eb8",
        "#4daf4a",
        "#984ea3",
        "#ff7f00",
        "#ffff33",
        "#a65628",
        "#f781bf",
      ];
      let colorIndex = 0;

      // Build sources object
      const sources = {};
      config.tileSources.forEach((src) => {
        sources[src.name] = {
          type: "vector",
          url: "pmtiles://" + src.path,
        };
      });

      // Create style with layers for ALL sources
      const style = {
        version: 8,
        sources: sources,
        layers: [
          {
            id: "background",
            type: "background",
            paint: { "background-color": "#1a1a2e" },
          },
        ],
      };

      // Track layers for toggle controls
      const layerGroups = {};

      // Helper to build color expression from extracted colors
      function buildColorExpression(colors, sourceLayer) {
        if (!colors || Object.keys(colors).length === 0) {
          return null;
        }

        // Build a case expression: ["case", condition1, color1, condition2, color2, ..., default]
        const expr = ["case"];
        for (const [category, color] of Object.entries(colors)) {
          if (category !== "unknown" && category !== "other" && color) {
            // Assume properties are boolean flags (==1 means true)
            expr.push(["==", ["get", category], 1]);
            expr.push(color);
          }
        }
        // Default color
        expr.push(colors.unknown || colors.other || "#888888");

        return expr;
      }

      // Add layers for each source
      config.tileSources.forEach((src, i) => {
        const isDataLayer = src.isOrphan !== false;
        const extracted = src.extractedStyle;

        // Determine colors to use
        let color;
        let colorExpr = null;

        if (
          extracted &&
          extracted.colors &&
          Object.keys(extracted.colors).length > 0
        ) {
          // Use extracted colors - build expression
          colorExpr = buildColorExpression(
            extracted.colors,
            extracted.sourceLayer
          );
          color = Object.values(extracted.colors)[0]; // Fallback single color
          console.log(
            "Using extracted colors for",
            src.name,
            "confidence:",
            extracted.confidence
          );
        } else {
          // Fall back to default palette
          color = isDataLayer
            ? DEFAULT_COLORS[colorIndex++ % DEFAULT_COLORS.length]
            : "#4a4a6a";
        }

        const layerType = extracted?.layerType || "line";

        // Get all discovered source layers, or fall back to single sourceLayer
        // This comes from actual tile inspection and is reliable
        let sourceLayers = extracted?.allLayers || [];
        if (sourceLayers.length === 0 && extracted?.sourceLayer) {
          sourceLayers = [extracted.sourceLayer];
        }

        const layerIds = [];

        // If we have discovered source layers, create a layer for each
        // If not, create layers without source-layer (will try to render all)
        if (sourceLayers.length > 0) {
          console.log(
            "Creating layers for source",
            src.name,
            "with discovered layers:",
            sourceLayers
          );

          sourceLayers.forEach((sourceLayer, idx) => {
            const suffix = sourceLayers.length > 1 ? `-${idx}` : "";

            // Line layer
            if (layerType === "line" || !isDataLayer || !extracted) {
              const lineId = src.name + "-line" + suffix;
              style.layers.push({
                id: lineId,
                type: "line",
                source: src.name,
                "source-layer": sourceLayer,
                paint: {
                  "line-color": colorExpr || color,
                  "line-width": isDataLayer ? 2 : 1,
                  "line-opacity": isDataLayer ? 0.9 : 0.5,
                },
              });
              layerIds.push(lineId);
            }

            // Fill layer for polygons
            if (layerType === "fill" || !extracted) {
              const fillId = src.name + "-fill" + suffix;
              style.layers.push({
                id: fillId,
                type: "fill",
                source: src.name,
                "source-layer": sourceLayer,
                filter: ["==", ["geometry-type"], "Polygon"],
                paint: {
                  "fill-color": colorExpr || color,
                  "fill-opacity": isDataLayer ? 0.4 : 0.2,
                },
              });
              layerIds.push(fillId);
            }

            // Circle layer for points
            if (layerType === "circle" || !extracted) {
              const circleId = src.name + "-circle" + suffix;
              style.layers.push({
                id: circleId,
                type: "circle",
                source: src.name,
                "source-layer": sourceLayer,
                filter: ["==", ["geometry-type"], "Point"],
                paint: {
                  "circle-color": colorExpr || color,
                  "circle-radius": isDataLayer ? 6 : 3,
                  "circle-stroke-color": "#ffffff",
                  "circle-stroke-width": isDataLayer ? 1 : 0,
                },
              });
              layerIds.push(circleId);
            }
          });
        } else {
          // No source layers discovered - this shouldn't happen for vector tiles
          // but handle gracefully by omitting source-layer
          console.warn(
            "No source layers discovered for",
            src.name,
            "- layers may not render correctly"
          );

          const lineId = src.name + "-line";
          style.layers.push({
            id: lineId,
            type: "line",
            source: src.name,
            paint: {
              "line-color": color,
              "line-width": 2,
              "line-opacity": 0.9,
            },
          });
          layerIds.push(lineId);
        }

        layerGroups[src.name] = {
          label:
            src.name +
            (extracted?.confidence
              ? ` (${Math.round(extracted.confidence * 100)}% styled)`
              : ""),
          layers: layerIds,
          isData: isDataLayer,
          hasExtractedStyle: !!(
            extracted &&
            extracted.colors &&
            Object.keys(extracted.colors).length > 0
          ),
          sourceLayers: sourceLayers,
        };
      });

      const map = new maplibregl.Map({
        container: "map",
        style: style,
        center: [-74.00390625, 40.71342256461031],
        zoom: 11,
        maxBounds: [
          [-74.53125, 40.44694705960049],
          [-73.4765625, 40.97989806962013],
        ],
      });

      map.addControl(new maplibregl.NavigationControl(), "top-right");
      map.addControl(new maplibregl.ScaleControl(), "bottom-right");

      // Add layer toggle controls
      map.on("load", () => {
        const controlsDiv = document.getElementById("layer-controls");

        Object.entries(layerGroups).forEach(([name, group]) => {
          const label = document.createElement("label");
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.checked = true;
          checkbox.addEventListener("change", (e) => {
            const visibility = e.target.checked ? "visible" : "none";
            group.layers.forEach((layerId) => {
              if (map.getLayer(layerId)) {
                map.setLayoutProperty(layerId, "visibility", visibility);
              }
            });
          });

          const span = document.createElement("span");
          let labelText = group.label;
          if (group.isData) {
            labelText += group.hasExtractedStyle ? " âœ“" : " (default style)";
          }
          span.textContent = labelText;

          // Build tooltip with source layer info
          let tooltip = group.hasExtractedStyle
            ? "Styling extracted from original JavaScript"
            : group.isData
            ? "Using default styling - original could not be extracted"
            : "Basemap layer";

          if (group.sourceLayers && group.sourceLayers.length > 0) {
            tooltip += "\n\nSource layers: " + group.sourceLayers.join(", ");
          }
          span.title = tooltip;

          label.appendChild(checkbox);
          label.appendChild(span);
          controlsDiv.appendChild(label);
        });
      });

      // Log errors for debugging
      map.on("error", (e) => {
        console.error("Map error:", e);
      });
    </script>
  </body>
</html>
