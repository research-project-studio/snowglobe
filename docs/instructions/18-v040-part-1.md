# Extended Data Sources Implementation Guide

## For Claude Code - v0.4.0

This document covers implementing support for:
1. **Raster tile sources** - PNG/JPG/WebP tiles → PMTiles
2. **GeoJSON sources** - Inline or URL-based → PMTiles via tippecanoe
3. **WMS/WMTS sources** - OGC services → raster PMTiles
4. **WFS sources** - OGC feature services → vector PMTiles via tippecanoe

**Design Principle**: All data should be stored as PMTiles for consistent, portable archives.

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                      Source Detection                            │
├─────────────────────────────────────────────────────────────────┤
│  Vector Tiles    Raster Tiles   GeoJSON    WMS/WMTS    WFS      │
│  (existing)      (new)          (new)      (new)       (new)    │
└──────┬───────────────┬────────────┬───────────┬──────────┬──────┘
       │               │            │           │          │
       ▼               ▼            ▼           ▼          ▼
┌──────────────────────────────────────────────────────────────────┐
│                    Conversion Layer                               │
├──────────────────────────────────────────────────────────────────┤
│  Direct PMTiles   Raster→PMT   tippecanoe  Tile Fetch  GeoJSON  │
│  (existing)       (new)        (new)       + PMT (new) → tippe  │
└──────────────────────────────────────────────────────────────────┘
       │               │            │           │          │
       ▼               ▼            ▼           ▼          ▼
┌──────────────────────────────────────────────────────────────────┐
│                      PMTiles Output                               │
│         All sources unified into portable .pmtiles files         │
└──────────────────────────────────────────────────────────────────┘
```

---

## Part 1: Raster Tile Sources

### 1.1 Overview

Raster tiles (PNG, JPG, WebP) are already captured by the extension. We need to:
1. Detect raster vs vector tiles
2. Store raster tiles in PMTiles format (PMTiles supports raster!)
3. Update viewer to handle raster sources

### 1.2 Detection Updates

**File**: `cli/src/webmap_archiver/har/classifier.py`

The classifier already detects raster tiles. Verify these patterns work:

```python
# Existing patterns - verify they're present
PATTERNS = [
    # Raster tiles
    (r'/(\d+)/(\d+)/(\d+)\.(png|jpg|jpeg|webp)', RequestType.RASTER_TILE, 0.85),
    (r'/tiles?/.*\.(png|jpg|jpeg|webp)', RequestType.RASTER_TILE, 0.7),
]
```

### 1.3 PMTiles Builder Updates

**File**: `cli/src/webmap_archiver/tiles/pmtiles.py`

Update `PMTilesBuilder` to handle raster tiles:

```python
from enum import Enum

class TileType(Enum):
    VECTOR = "vector"  # MVT/PBF tiles
    RASTER_PNG = "raster_png"
    RASTER_JPG = "raster_jpg"
    RASTER_WEBP = "raster_webp"


class PMTilesBuilder:
    """Build PMTiles archives from captured tiles."""
    
    def __init__(
        self, 
        output_path: Path,
        tile_type: TileType = TileType.VECTOR
    ):
        self.output_path = output_path
        self.tile_type = tile_type
        self.tiles: dict[tuple[int, int, int], bytes] = {}
        self.metadata = PMTilesMetadata()
    
    def add_tile(self, coord: TileCoordinate, content: bytes) -> None:
        """Add a tile to the archive."""
        # For raster tiles, don't gzip (they're already compressed)
        if self.tile_type == TileType.VECTOR:
            # Existing logic - handle gzip
            if content[:2] == b'\x1f\x8b':  # Already gzipped
                self.tiles[(coord.z, coord.x, coord.y)] = content
            else:
                import gzip
                self.tiles[(coord.z, coord.x, coord.y)] = gzip.compress(content)
        else:
            # Raster tiles - store as-is (PNG/JPG already compressed)
            self.tiles[(coord.z, coord.x, coord.y)] = content
    
    def set_metadata(self, metadata: PMTilesMetadata) -> None:
        """Set archive metadata."""
        self.metadata = metadata
        # Set tile type in metadata
        self.metadata.tile_type = self.tile_type.value
    
    def _get_pmtiles_tile_type(self) -> int:
        """Get PMTiles spec tile type constant."""
        # PMTiles v3 spec tile types:
        # 0 = unknown, 1 = mvt, 2 = png, 3 = jpeg, 4 = webp
        return {
            TileType.VECTOR: 1,      # MVT
            TileType.RASTER_PNG: 2,  # PNG
            TileType.RASTER_JPG: 3,  # JPEG
            TileType.RASTER_WEBP: 4, # WebP
        }.get(self.tile_type, 0)
    
    def build(self) -> None:
        """Build the PMTiles archive."""
        import pmtiles
        from pmtiles.writer import Writer
        from pmtiles.tile import TileType as PMTileType
        
        # Map our type to pmtiles library type
        pm_tile_type = {
            TileType.VECTOR: PMTileType.MVT,
            TileType.RASTER_PNG: PMTileType.PNG,
            TileType.RASTER_JPG: PMTileType.JPEG,
            TileType.RASTER_WEBP: PMTileType.WEBP,
        }.get(self.tile_type, PMTileType.MVT)
        
        with open(self.output_path, 'wb') as f:
            writer = Writer(f)
            
            # Set header with tile type
            writer.write_header(
                tile_type=pm_tile_type,
                tile_compression=pmtiles.Compression.GZIP if self.tile_type == TileType.VECTOR else pmtiles.Compression.NONE,
            )
            
            # Write tiles
            for (z, x, y), data in sorted(self.tiles.items()):
                writer.write_tile(z, x, y, data)
            
            # Write metadata
            writer.finalize(metadata=self.metadata.to_dict())
```

### 1.4 Processor Updates

**File**: `cli/src/webmap_archiver/capture/processor.py`

Update tile source detection to track tile type:

```python
@dataclass
class TileSourceInfo:
    name: str
    url_template: str
    tile_type: str  # "vector" or "raster"
    format: str     # "pbf", "mvt", "png", "jpg", "webp"
    tiles: list[tuple[TileCoordinate, bytes]]
    
    @property
    def is_raster(self) -> bool:
        return self.tile_type == "raster"
    
    @property
    def pmtiles_tile_type(self) -> TileType:
        if self.tile_type == "vector":
            return TileType.VECTOR
        format_map = {
            "png": TileType.RASTER_PNG,
            "jpg": TileType.RASTER_JPG,
            "jpeg": TileType.RASTER_JPG,
            "webp": TileType.RASTER_WEBP,
        }
        return format_map.get(self.format.lower(), TileType.RASTER_PNG)
```

### 1.5 Viewer Updates for Raster

**File**: `cli/src/webmap_archiver/viewer/generator.py`

Update style generation to handle raster sources:

```javascript
// When generating style for non-captured-style mode
if (src.tileType === 'raster') {
    sources[src.name] = {
        type: 'raster',
        url: 'pmtiles://' + src.path,
        tileSize: 256  // Standard raster tile size
    };
    
    // Add raster layer
    style.layers.push({
        id: src.name + '-raster',
        type: 'raster',
        source: src.name,
        paint: {
            'raster-opacity': 1
        }
    });
} else {
    // Existing vector source logic
    sources[src.name] = {
        type: 'vector',
        url: 'pmtiles://' + src.path
    };
}
```

### 1.6 Style Rewriting for Raster

**File**: `cli/src/webmap_archiver/api.py`

Update `_rewrite_style_sources()` to handle raster sources:

```python
def _rewrite_style_sources(
    style: dict, 
    url_patterns: dict[str, str],
    source_types: dict[str, str]  # NEW: source_name -> "vector" or "raster"
) -> dict:
    """Rewrite style sources to use local PMTiles."""
    
    if 'sources' not in style:
        return style
    
    for source_name, source_def in style['sources'].items():
        source_type = source_def.get('type', 'vector')
        
        # Find matching PMTiles file
        pmtiles_file = _find_matching_pmtiles(source_name, source_def, url_patterns)
        
        if pmtiles_file:
            if source_type == 'raster':
                # Raster source rewrite
                style['sources'][source_name] = {
                    'type': 'raster',
                    'url': f'pmtiles://{pmtiles_file}',
                    'tileSize': source_def.get('tileSize', 256)
                }
            else:
                # Vector source rewrite (existing logic)
                style['sources'][source_name] = {
                    'type': 'vector',
                    'url': f'pmtiles://{pmtiles_file}'
                }
    
    return style
```

---

## Part 2: GeoJSON Sources

### 2.1 Overview

GeoJSON sources in MapLibre styles can be:
1. **Inline data** - GeoJSON embedded directly in the style
2. **URL reference** - External GeoJSON file loaded at runtime
3. **Large datasets** - May need conversion to vector tiles for performance

**Strategy**:
- Small GeoJSON (< 1MB): Keep as GeoJSON in archive
- Large GeoJSON (≥ 1MB): Convert to vector tiles via tippecanoe

### 2.2 GeoJSON Detection

**File**: `cli/src/webmap_archiver/capture/parser.py`

Add GeoJSON extraction from captured style:

```python
@dataclass
class CapturedGeoJSON:
    """A GeoJSON source from the map style."""
    source_name: str
    data: dict | None  # Inline GeoJSON data
    url: str | None    # URL if external
    size_bytes: int
    
    @property
    def is_inline(self) -> bool:
        return self.data is not None
    
    @property
    def needs_tiling(self) -> bool:
        """Check if GeoJSON should be converted to vector tiles."""
        return self.size_bytes >= 1_000_000  # 1MB threshold


def extract_geojson_sources(style: dict) -> list[CapturedGeoJSON]:
    """Extract GeoJSON sources from a MapLibre style."""
    geojson_sources = []
    
    if 'sources' not in style:
        return geojson_sources
    
    for source_name, source_def in style['sources'].items():
        if source_def.get('type') != 'geojson':
            continue
        
        data = source_def.get('data')
        
        if isinstance(data, dict):
            # Inline GeoJSON
            import json
            data_str = json.dumps(data)
            geojson_sources.append(CapturedGeoJSON(
                source_name=source_name,
                data=data,
                url=None,
                size_bytes=len(data_str.encode('utf-8'))
            ))
        elif isinstance(data, str):
            # URL reference
            geojson_sources.append(CapturedGeoJSON(
                source_name=source_name,
                data=None,
                url=data,
                size_bytes=0  # Unknown until fetched
            ))
    
    return geojson_sources
```

### 2.3 GeoJSON Fetching

**File**: `cli/src/webmap_archiver/sources/geojson_fetcher.py` (NEW)

```python
"""
Fetch external GeoJSON sources.
"""

import aiohttp
import asyncio
from dataclasses import dataclass
from pathlib import Path
import json


@dataclass
class FetchedGeoJSON:
    source_name: str
    data: dict
    size_bytes: int
    original_url: str


class GeoJSONFetcher:
    """Fetch external GeoJSON files."""
    
    def __init__(
        self,
        timeout: float = 30.0,
        max_size_mb: float = 50.0
    ):
        self.timeout = timeout
        self.max_size_bytes = int(max_size_mb * 1024 * 1024)
    
    async def fetch(self, url: str, source_name: str) -> FetchedGeoJSON | None:
        """Fetch a single GeoJSON file."""
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, timeout=self.timeout) as response:
                    if response.status != 200:
                        print(f"[GeoJSON] Failed to fetch {url}: {response.status}")
                        return None
                    
                    # Check content length
                    content_length = response.headers.get('Content-Length')
                    if content_length and int(content_length) > self.max_size_bytes:
                        print(f"[GeoJSON] {url} exceeds max size ({content_length} bytes)")
                        return None
                    
                    content = await response.read()
                    data = json.loads(content)
                    
                    return FetchedGeoJSON(
                        source_name=source_name,
                        data=data,
                        size_bytes=len(content),
                        original_url=url
                    )
        except Exception as e:
            print(f"[GeoJSON] Error fetching {url}: {e}")
            return None
    
    async def fetch_all(
        self, 
        sources: list[tuple[str, str]]  # (source_name, url)
    ) -> list[FetchedGeoJSON]:
        """Fetch multiple GeoJSON files concurrently."""
        tasks = [self.fetch(url, name) for name, url in sources]
        results = await asyncio.gather(*tasks)
        return [r for r in results if r is not None]
```

### 2.4 Tippecanoe Integration

**File**: `cli/src/webmap_archiver/sources/tippecanoe.py` (NEW)

```python
"""
Convert GeoJSON to vector tiles using tippecanoe.
"""

import subprocess
import tempfile
from pathlib import Path
from dataclasses import dataclass
import shutil
import json


@dataclass
class TippecanoeConfig:
    """Configuration for tippecanoe conversion."""
    min_zoom: int = 0
    max_zoom: int = 14
    layer_name: str | None = None  # Defaults to source name
    drop_densest_as_needed: bool = True
    extend_zooms_if_still_dropping: bool = True
    force: bool = True  # Overwrite existing output


class TippecanoeConverter:
    """Convert GeoJSON to PMTiles using tippecanoe."""
    
    def __init__(self):
        self._check_tippecanoe()
    
    def _check_tippecanoe(self) -> None:
        """Verify tippecanoe is installed."""
        if not shutil.which('tippecanoe'):
            raise RuntimeError(
                "tippecanoe not found. Install with: "
                "brew install tippecanoe (macOS) or "
                "apt-get install tippecanoe (Debian/Ubuntu)"
            )
    
    def convert(
        self,
        geojson_data: dict,
        output_path: Path,
        config: TippecanoeConfig | None = None,
        source_name: str = "data"
    ) -> Path:
        """
        Convert GeoJSON to PMTiles.
        
        Args:
            geojson_data: GeoJSON dict
            output_path: Output .pmtiles path
            config: Tippecanoe configuration
            source_name: Name for the layer
            
        Returns:
            Path to created PMTiles file
        """
        config = config or TippecanoeConfig()
        layer_name = config.layer_name or source_name
        
        with tempfile.TemporaryDirectory() as temp_dir:
            # Write GeoJSON to temp file
            geojson_path = Path(temp_dir) / "input.geojson"
            with open(geojson_path, 'w') as f:
                json.dump(geojson_data, f)
            
            # Build tippecanoe command
            cmd = [
                'tippecanoe',
                '-o', str(output_path),
                '-z', str(config.max_zoom),
                '-Z', str(config.min_zoom),
                '-l', layer_name,  # Layer name
                '--no-tile-compression',  # PMTiles handles compression
            ]
            
            if config.drop_densest_as_needed:
                cmd.append('--drop-densest-as-needed')
            
            if config.extend_zooms_if_still_dropping:
                cmd.append('--extend-zooms-if-still-dropping')
            
            if config.force:
                cmd.append('--force')
            
            cmd.append(str(geojson_path))
            
            # Run tippecanoe
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True
            )
            
            if result.returncode != 0:
                raise RuntimeError(f"tippecanoe failed: {result.stderr}")
            
            return output_path
    
    def convert_multiple(
        self,
        sources: list[tuple[str, dict]],  # (source_name, geojson_data)
        output_dir: Path,
        config: TippecanoeConfig | None = None
    ) -> dict[str, Path]:
        """
        Convert multiple GeoJSON sources to PMTiles.
        
        Returns:
            Dict mapping source_name to PMTiles path
        """
        results = {}
        
        for source_name, geojson_data in sources:
            output_path = output_dir / f"{source_name}.pmtiles"
            self.convert(
                geojson_data=geojson_data,
                output_path=output_path,
                config=config,
                source_name=source_name
            )
            results[source_name] = output_path
        
        return results
```

### 2.5 GeoJSON Processing in Archive Creation

**File**: `cli/src/webmap_archiver/api.py`

Add GeoJSON handling to archive creation:

```python
async def _process_geojson_sources(
    style: dict,
    temp_dir: Path,
    verbose: bool = False
) -> dict[str, Path]:
    """
    Process GeoJSON sources from style.
    
    Returns:
        Dict mapping source_name to PMTiles path (or GeoJSON path for small sources)
    """
    from .sources.geojson_fetcher import GeoJSONFetcher
    from .sources.tippecanoe import TippecanoeConverter, TippecanoeConfig
    from .capture.parser import extract_geojson_sources
    
    geojson_sources = extract_geojson_sources(style)
    
    if not geojson_sources:
        return {}
    
    if verbose:
        print(f"[GeoJSON] Found {len(geojson_sources)} GeoJSON sources")
    
    results = {}
    
    # Fetch external GeoJSON files
    external_sources = [(s.source_name, s.url) for s in geojson_sources if s.url]
    if external_sources:
        fetcher = GeoJSONFetcher()
        fetched = await fetcher.fetch_all(external_sources)
        
        # Update sources with fetched data
        for f in fetched:
            for s in geojson_sources:
                if s.source_name == f.source_name:
                    s.data = f.data
                    s.size_bytes = f.size_bytes
                    break
    
    # Process each source
    TILING_THRESHOLD = 1_000_000  # 1MB
    
    for source in geojson_sources:
        if source.data is None:
            if verbose:
                print(f"[GeoJSON] Skipping {source.source_name} - no data")
            continue
        
        if source.size_bytes >= TILING_THRESHOLD:
            # Convert to vector tiles
            if verbose:
                print(f"[GeoJSON] Converting {source.source_name} to vector tiles ({source.size_bytes:,} bytes)")
            
            try:
                converter = TippecanoeConverter()
                output_path = temp_dir / "tiles" / f"{source.source_name}.pmtiles"
                output_path.parent.mkdir(parents=True, exist_ok=True)
                
                converter.convert(
                    geojson_data=source.data,
                    output_path=output_path,
                    source_name=source.source_name
                )
                
                results[source.source_name] = output_path
            except Exception as e:
                print(f"[GeoJSON] Failed to convert {source.source_name}: {e}")
                # Fall back to storing as GeoJSON
                geojson_path = temp_dir / "data" / f"{source.source_name}.geojson"
                geojson_path.parent.mkdir(parents=True, exist_ok=True)
                with open(geojson_path, 'w') as f:
                    json.dump(source.data, f)
                results[source.source_name] = geojson_path
        else:
            # Store as GeoJSON (small enough)
            if verbose:
                print(f"[GeoJSON] Storing {source.source_name} as GeoJSON ({source.size_bytes:,} bytes)")
            
            geojson_path = temp_dir / "data" / f"{source.source_name}.geojson"
            geojson_path.parent.mkdir(parents=True, exist_ok=True)
            with open(geojson_path, 'w') as f:
                json.dump(source.data, f)
            results[source.source_name] = geojson_path
    
    return results
```

### 2.6 Style Rewriting for GeoJSON

Update style to reference local GeoJSON or converted PMTiles:

```python
def _rewrite_geojson_sources(
    style: dict,
    geojson_paths: dict[str, Path]
) -> dict:
    """Rewrite GeoJSON sources to use local files."""
    
    if 'sources' not in style:
        return style
    
    for source_name, local_path in geojson_paths.items():
        if source_name not in style['sources']:
            continue
        
        if local_path.suffix == '.pmtiles':
            # Converted to vector tiles
            style['sources'][source_name] = {
                'type': 'vector',
                'url': f'pmtiles://tiles/{local_path.name}'
            }
        else:
            # Still GeoJSON
            style['sources'][source_name] = {
                'type': 'geojson',
                'data': f'data/{local_path.name}'
            }
    
    return style
```

---

## Part 3: WMS/WMTS Sources

### 3.1 Overview

OGC Web Map Services provide raster map images. WMTS provides pre-tiled rasters.

**Strategy**:
- WMTS: Capture tiles directly (similar to raster tiles)
- WMS: Generate tiles by requesting images at tile boundaries

### 3.2 WMS/WMTS Detection

**File**: `cli/src/webmap_archiver/har/classifier.py`

Add patterns for OGC services:

```python
# Add to PATTERNS list
PATTERNS = [
    # ... existing patterns ...
    
    # WMTS
    (r'/wmts', RequestType.WMTS, 0.9),
    (r'service=wmts', RequestType.WMTS, 0.95),
    (r'/tile/\d+/\d+/\d+', RequestType.WMTS, 0.7),
    (r'TileMatrix=', RequestType.WMTS, 0.9),
    
    # WMS
    (r'service=wms', RequestType.WMS, 0.95),
    (r'request=getmap', RequestType.WMS, 0.95),
    (r'/wms\?', RequestType.WMS, 0.85),
]

class RequestType(Enum):
    # ... existing types ...
    WMTS = auto()
    WMS = auto()
    WFS = auto()
```

### 3.3 WMTS Tile Extraction

**File**: `cli/src/webmap_archiver/sources/wmts.py` (NEW)

```python
"""
Extract and convert WMTS tiles.
"""

from dataclasses import dataclass
from urllib.parse import urlparse, parse_qs
import re


@dataclass
class WMTSCapabilities:
    """Parsed WMTS capabilities."""
    layer: str
    tile_matrix_set: str
    format: str  # image/png, image/jpeg, etc.
    url_template: str
    min_zoom: int
    max_zoom: int


class WMTSTileExtractor:
    """Extract tile coordinates from WMTS URLs."""
    
    # Common WMTS URL patterns
    PATTERNS = [
        # KVP style: ...?TileMatrix=12&TileCol=2048&TileRow=1024
        re.compile(r'TileMatrix=(\d+).*TileCol=(\d+).*TileRow=(\d+)', re.I),
        
        # RESTful style: .../layer/TileMatrixSet/TileMatrix/TileRow/TileCol.png
        re.compile(r'/(\d+)/(\d+)/(\d+)\.(png|jpg|jpeg)'),
        
        # ArcGIS style: .../tile/z/y/x
        re.compile(r'/tile/(\d+)/(\d+)/(\d+)'),
    ]
    
    def extract_coordinates(self, url: str) -> tuple[int, int, int] | None:
        """Extract z, x, y from WMTS URL."""
        for pattern in self.PATTERNS:
            match = pattern.search(url)
            if match:
                groups = match.groups()
                if len(groups) >= 3:
                    z = int(groups[0])
                    # Pattern-dependent x/y order
                    if 'TileCol' in url.upper():
                        x, y = int(groups[1]), int(groups[2])
                    else:
                        y, x = int(groups[1]), int(groups[2])
                    return z, x, y
        return None
    
    def get_format(self, url: str) -> str:
        """Detect tile format from URL."""
        url_lower = url.lower()
        if 'format=image/png' in url_lower or url_lower.endswith('.png'):
            return 'png'
        elif 'format=image/jpeg' in url_lower or url_lower.endswith('.jpg'):
            return 'jpg'
        elif url_lower.endswith('.webp'):
            return 'webp'
        return 'png'  # Default
```

### 3.4 WMS Tile Generation

**File**: `cli/src/webmap_archiver/sources/wms.py` (NEW)

```python
"""
Generate tiles from WMS services.

WMS provides arbitrary bounding box images.
We generate tiles by calculating bbox for each tile coordinate.
"""

import aiohttp
from dataclasses import dataclass
from pathlib import Path
import math
from typing import Iterator


@dataclass
class WMSConfig:
    """WMS service configuration."""
    base_url: str
    layers: str
    format: str = "image/png"
    crs: str = "EPSG:3857"  # Web Mercator
    version: str = "1.3.0"
    styles: str = ""
    transparent: bool = True
    tile_size: int = 256


class WMSTileGenerator:
    """Generate map tiles from WMS service."""
    
    def __init__(self, config: WMSConfig):
        self.config = config
    
    def _tile_to_bbox(self, z: int, x: int, y: int) -> tuple[float, float, float, float]:
        """Convert tile coordinates to Web Mercator bounding box."""
        # Earth circumference in meters
        EARTH_CIRCUMFERENCE = 40075016.685578488
        
        n = 2 ** z
        tile_size_meters = EARTH_CIRCUMFERENCE / n
        
        # Origin is at top-left (-180, 85.05...)
        origin_x = -EARTH_CIRCUMFERENCE / 2
        origin_y = EARTH_CIRCUMFERENCE / 2
        
        min_x = origin_x + x * tile_size_meters
        max_x = min_x + tile_size_meters
        max_y = origin_y - y * tile_size_meters
        min_y = max_y - tile_size_meters
        
        return (min_x, min_y, max_x, max_y)
    
    def _build_url(self, z: int, x: int, y: int) -> str:
        """Build WMS GetMap URL for a tile."""
        bbox = self._tile_to_bbox(z, x, y)
        
        params = {
            'SERVICE': 'WMS',
            'VERSION': self.config.version,
            'REQUEST': 'GetMap',
            'LAYERS': self.config.layers,
            'STYLES': self.config.styles,
            'CRS': self.config.crs,
            'BBOX': f'{bbox[0]},{bbox[1]},{bbox[2]},{bbox[3]}',
            'WIDTH': str(self.config.tile_size),
            'HEIGHT': str(self.config.tile_size),
            'FORMAT': self.config.format,
            'TRANSPARENT': 'TRUE' if self.config.transparent else 'FALSE',
        }
        
        # Handle version differences
        if self.config.version.startswith('1.1'):
            params['SRS'] = params.pop('CRS')
        
        query = '&'.join(f'{k}={v}' for k, v in params.items())
        
        # Handle base URL with existing query string
        separator = '&' if '?' in self.config.base_url else '?'
        return f'{self.config.base_url}{separator}{query}'
    
    async def fetch_tile(
        self, 
        session: aiohttp.ClientSession,
        z: int, x: int, y: int
    ) -> bytes | None:
        """Fetch a single tile from WMS."""
        url = self._build_url(z, x, y)
        
        try:
            async with session.get(url, timeout=30) as response:
                if response.status == 200:
                    return await response.read()
                return None
        except Exception as e:
            print(f"[WMS] Error fetching tile {z}/{x}/{y}: {e}")
            return None
    
    def generate_tile_coords(
        self,
        bounds: tuple[float, float, float, float],  # minx, miny, maxx, maxy (meters)
        min_zoom: int,
        max_zoom: int
    ) -> Iterator[tuple[int, int, int]]:
        """Generate tile coordinates covering bounds."""
        EARTH_CIRCUMFERENCE = 40075016.685578488
        
        for z in range(min_zoom, max_zoom + 1):
            n = 2 ** z
            tile_size = EARTH_CIRCUMFERENCE / n
            origin_x = -EARTH_CIRCUMFERENCE / 2
            origin_y = EARTH_CIRCUMFERENCE / 2
            
            min_x = int((bounds[0] - origin_x) / tile_size)
            max_x = int((bounds[2] - origin_x) / tile_size)
            min_y = int((origin_y - bounds[3]) / tile_size)
            max_y = int((origin_y - bounds[1]) / tile_size)
            
            for x in range(max(0, min_x), min(n, max_x + 1)):
                for y in range(max(0, min_y), min(n, max_y + 1)):
                    yield z, x, y
```

---

## Part 4: WFS Sources (Vector Features)

### 4.1 Overview

OGC Web Feature Service provides vector features (GeoJSON, GML).

**Strategy**: Fetch features as GeoJSON → Convert to vector tiles via tippecanoe

### 4.2 WFS Fetcher

**File**: `cli/src/webmap_archiver/sources/wfs.py` (NEW)

```python
"""
Fetch features from WFS services and convert to GeoJSON.
"""

import aiohttp
from dataclasses import dataclass
import json
from typing import Iterator


@dataclass 
class WFSConfig:
    """WFS service configuration."""
    base_url: str
    type_name: str  # Layer/feature type
    version: str = "2.0.0"
    output_format: str = "application/json"  # GeoJSON
    max_features: int = 10000
    srs: str = "EPSG:4326"


class WFSFetcher:
    """Fetch features from WFS service."""
    
    def __init__(self, config: WFSConfig):
        self.config = config
    
    def _build_url(self, start_index: int = 0) -> str:
        """Build WFS GetFeature URL."""
        params = {
            'SERVICE': 'WFS',
            'VERSION': self.config.version,
            'REQUEST': 'GetFeature',
            'TYPENAMES': self.config.type_name,
            'OUTPUTFORMAT': self.config.output_format,
            'SRSNAME': self.config.srs,
            'COUNT': str(self.config.max_features),
            'STARTINDEX': str(start_index),
        }
        
        # Handle version differences
        if self.config.version.startswith('1.'):
            params['TYPENAME'] = params.pop('TYPENAMES')
            params['MAXFEATURES'] = params.pop('COUNT')
        
        query = '&'.join(f'{k}={v}' for k, v in params.items())
        separator = '&' if '?' in self.config.base_url else '?'
        return f'{self.config.base_url}{separator}{query}'
    
    async def fetch_all_features(
        self, 
        session: aiohttp.ClientSession
    ) -> dict:
        """
        Fetch all features, handling pagination.
        
        Returns:
            GeoJSON FeatureCollection
        """
        all_features = []
        start_index = 0
        
        while True:
            url = self._build_url(start_index)
            
            try:
                async with session.get(url, timeout=60) as response:
                    if response.status != 200:
                        print(f"[WFS] Error: {response.status}")
                        break
                    
                    data = await response.json()
                    
                    if 'features' not in data:
                        break
                    
                    features = data['features']
                    if not features:
                        break
                    
                    all_features.extend(features)
                    
                    # Check if more features available
                    if len(features) < self.config.max_features:
                        break
                    
                    start_index += len(features)
                    print(f"[WFS] Fetched {len(all_features)} features so far...")
                    
            except Exception as e:
                print(f"[WFS] Error fetching features: {e}")
                break
        
        return {
            'type': 'FeatureCollection',
            'features': all_features
        }
    
    async def fetch_and_convert(
        self,
        output_path: Path,
        session: aiohttp.ClientSession | None = None
    ) -> Path:
        """
        Fetch WFS features and convert to PMTiles.
        
        Returns:
            Path to created PMTiles file
        """
        from .tippecanoe import TippecanoeConverter
        
        if session is None:
            async with aiohttp.ClientSession() as session:
                return await self._do_fetch_and_convert(session, output_path)
        else:
            return await self._do_fetch_and_convert(session, output_path)
    
    async def _do_fetch_and_convert(
        self,
        session: aiohttp.ClientSession,
        output_path: Path
    ) -> Path:
        geojson = await self.fetch_all_features(session)
        
        print(f"[WFS] Fetched {len(geojson['features'])} total features")
        
        converter = TippecanoeConverter()
        return converter.convert(
            geojson_data=geojson,
            output_path=output_path,
            source_name=self.config.type_name.split(':')[-1]  # Remove namespace
        )
```

---

## Part 5: Integration into Archive Pipeline

### 5.1 Unified Source Processing

**File**: `cli/src/webmap_archiver/sources/processor.py` (NEW)

```python
"""
Unified processor for all source types.
"""

from dataclasses import dataclass
from pathlib import Path
from enum import Enum
from typing import Any


class SourceType(Enum):
    VECTOR_TILES = "vector_tiles"
    RASTER_TILES = "raster_tiles"
    GEOJSON = "geojson"
    GEOJSON_URL = "geojson_url"
    WMS = "wms"
    WMTS = "wmts"
    WFS = "wfs"


@dataclass
class ProcessedSource:
    """Result of processing a source."""
    name: str
    source_type: SourceType
    output_path: Path
    output_format: str  # "pmtiles" or "geojson"
    metadata: dict


class UnifiedSourceProcessor:
    """Process all source types into archive-ready format."""
    
    def __init__(self, output_dir: Path, verbose: bool = False):
        self.output_dir = output_dir
        self.verbose = verbose
        self.tiles_dir = output_dir / "tiles"
        self.data_dir = output_dir / "data"
        self.tiles_dir.mkdir(parents=True, exist_ok=True)
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    async def process_source(
        self,
        name: str,
        source_type: SourceType,
        data: Any,
        config: dict | None = None
    ) -> ProcessedSource:
        """Process a source based on its type."""
        
        if source_type == SourceType.VECTOR_TILES:
            return self._process_vector_tiles(name, data)
        
        elif source_type == SourceType.RASTER_TILES:
            return self._process_raster_tiles(name, data, config)
        
        elif source_type == SourceType.GEOJSON:
            return await self._process_geojson(name, data)
        
        elif source_type == SourceType.GEOJSON_URL:
            return await self._process_geojson_url(name, data)
        
        elif source_type == SourceType.WMS:
            return await self._process_wms(name, config)
        
        elif source_type == SourceType.WMTS:
            return self._process_wmts(name, data, config)
        
        elif source_type == SourceType.WFS:
            return await self._process_wfs(name, config)
        
        else:
            raise ValueError(f"Unknown source type: {source_type}")
    
    def _process_vector_tiles(
        self, 
        name: str, 
        tiles: list[tuple]
    ) -> ProcessedSource:
        """Process captured vector tiles into PMTiles."""
        from ..tiles.pmtiles import PMTilesBuilder, TileType
        
        output_path = self.tiles_dir / f"{name}.pmtiles"
        builder = PMTilesBuilder(output_path, TileType.VECTOR)
        
        for coord, content in tiles:
            builder.add_tile(coord, content)
        
        builder.build()
        
        return ProcessedSource(
            name=name,
            source_type=SourceType.VECTOR_TILES,
            output_path=output_path,
            output_format="pmtiles",
            metadata={"tile_count": len(tiles)}
        )
    
    def _process_raster_tiles(
        self,
        name: str,
        tiles: list[tuple],
        config: dict | None = None
    ) -> ProcessedSource:
        """Process captured raster tiles into PMTiles."""
        from ..tiles.pmtiles import PMTilesBuilder, TileType
        
        # Detect format from first tile or config
        tile_format = config.get('format', 'png') if config else 'png'
        tile_type = {
            'png': TileType.RASTER_PNG,
            'jpg': TileType.RASTER_JPG,
            'jpeg': TileType.RASTER_JPG,
            'webp': TileType.RASTER_WEBP,
        }.get(tile_format, TileType.RASTER_PNG)
        
        output_path = self.tiles_dir / f"{name}.pmtiles"
        builder = PMTilesBuilder(output_path, tile_type)
        
        for coord, content in tiles:
            builder.add_tile(coord, content)
        
        builder.build()
        
        return ProcessedSource(
            name=name,
            source_type=SourceType.RASTER_TILES,
            output_path=output_path,
            output_format="pmtiles",
            metadata={"tile_count": len(tiles), "format": tile_format}
        )
    
    async def _process_geojson(
        self,
        name: str,
        data: dict
    ) -> ProcessedSource:
        """Process inline GeoJSON."""
        import json
        
        size = len(json.dumps(data).encode('utf-8'))
        
        if size >= 1_000_000:  # 1MB threshold
            # Convert to vector tiles
            from .tippecanoe import TippecanoeConverter
            
            output_path = self.tiles_dir / f"{name}.pmtiles"
            converter = TippecanoeConverter()
            converter.convert(data, output_path, source_name=name)
            
            return ProcessedSource(
                name=name,
                source_type=SourceType.GEOJSON,
                output_path=output_path,
                output_format="pmtiles",
                metadata={"original_size": size, "converted": True}
            )
        else:
            # Store as GeoJSON
            output_path = self.data_dir / f"{name}.geojson"
            with open(output_path, 'w') as f:
                json.dump(data, f)
            
            return ProcessedSource(
                name=name,
                source_type=SourceType.GEOJSON,
                output_path=output_path,
                output_format="geojson",
                metadata={"size": size, "converted": False}
            )
    
    # ... additional methods for URL, WMS, WMTS, WFS ...
```

### 5.2 Updated Archive Manifest

Update manifest to include source type information:

```json
{
  "version": "2.1",
  "sources": [
    {
      "name": "basemap",
      "type": "vector",
      "originalType": "vector_tiles",
      "path": "tiles/basemap.pmtiles",
      "format": "pmtiles"
    },
    {
      "name": "satellite",
      "type": "raster",
      "originalType": "wmts",
      "path": "tiles/satellite.pmtiles",
      "format": "pmtiles"
    },
    {
      "name": "boundaries",
      "type": "vector",
      "originalType": "wfs",
      "path": "tiles/boundaries.pmtiles",
      "format": "pmtiles",
      "convertedFrom": "WFS"
    },
    {
      "name": "points",
      "type": "geojson",
      "originalType": "geojson",
      "path": "data/points.geojson",
      "format": "geojson"
    }
  ]
}
```

---

## Testing Checklist

### Raster Tiles
- [ ] Detect raster tile URLs correctly
- [ ] Store raster tiles in PMTiles without re-compression
- [ ] Viewer displays raster layers
- [ ] Raster PMTiles loads in pmtiles.io

### GeoJSON
- [ ] Extract inline GeoJSON from style
- [ ] Fetch external GeoJSON URLs
- [ ] Small GeoJSON stored as-is
- [ ] Large GeoJSON converted via tippecanoe
- [ ] Viewer displays GeoJSON layers
- [ ] Converted PMTiles loads in pmtiles.io

### WMS/WMTS
- [ ] Detect WMS/WMTS URLs in HAR
- [ ] Extract WMTS tiles correctly
- [ ] Generate tiles from WMS (if applicable)
- [ ] Store as raster PMTiles

### WFS
- [ ] Detect WFS URLs
- [ ] Fetch all features with pagination
- [ ] Convert to vector tiles via tippecanoe
- [ ] Viewer displays WFS-derived layers

---

## Dependencies

Add to `cli/pyproject.toml`:

```toml
[project]
dependencies = [
    # ... existing ...
    "pmtiles>=3.0.0",
    "aiohttp>=3.8.0",
]

[project.optional-dependencies]
ogc = [
    # For WMS/WFS parsing
    "OWSLib>=0.29.0",
]
```

External tools required:
- **tippecanoe**: For GeoJSON → vector tiles conversion
  - macOS: `brew install tippecanoe`
  - Linux: `apt-get install tippecanoe` or build from source

---

## Files to Create/Modify

| File | Action | Description |
|------|--------|-------------|
| `cli/src/webmap_archiver/tiles/pmtiles.py` | Modify | Add raster tile support |
| `cli/src/webmap_archiver/sources/__init__.py` | Create | New sources package |
| `cli/src/webmap_archiver/sources/tippecanoe.py` | Create | Tippecanoe integration |
| `cli/src/webmap_archiver/sources/geojson_fetcher.py` | Create | GeoJSON URL fetching |
| `cli/src/webmap_archiver/sources/wmts.py` | Create | WMTS tile extraction |
| `cli/src/webmap_archiver/sources/wms.py` | Create | WMS tile generation |
| `cli/src/webmap_archiver/sources/wfs.py` | Create | WFS feature fetching |
| `cli/src/webmap_archiver/sources/processor.py` | Create | Unified source processor |
| `cli/src/webmap_archiver/har/classifier.py` | Modify | Add WMS/WMTS/WFS patterns |
| `cli/src/webmap_archiver/api.py` | Modify | Integrate source processing |
| `cli/src/webmap_archiver/viewer/generator.py` | Modify | Handle raster sources |